[{"fullname": "tempgen", "modulename": "tempgen", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.libs", "modulename": "tempgen.libs", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.libs.num2t4ru", "modulename": "tempgen.libs.num2t4ru", "qualname": "", "type": "module", "doc": "<p>Created on 04.07.2011\nChanged on 13.03.2016 by Artem Tiumentcev\n@author: Sergey Prokhorov <a href=\"&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x6d;&#x65;&#x40;&#x73;&#101;&#x72;&#105;&#x79;&#x70;&#115;&#46;&#114;u\">&#x6d;&#x65;&#x40;&#x73;&#101;&#x72;&#105;&#x79;&#x70;&#115;&#46;&#114;u</a></p>\n"}, {"fullname": "tempgen.libs.num2t4ru.thousand", "modulename": "tempgen.libs.num2t4ru", "qualname": "thousand", "type": "function", "doc": "<p>Converts numbers from 19 to 999</p>\n", "parameters": ["rest", "sex"], "funcdef": "def"}, {"fullname": "tempgen.libs.num2t4ru.num2text", "modulename": "tempgen.libs.num2t4ru", "qualname": "num2text", "type": "function", "doc": "<p>http://ru.wikipedia.org/wiki/Gettext#.D0.9C.D0.BD.D0.BE.D0.B6.D0.B5.D1.81.    D1.82.D0.B2.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D1.87.D0.B8.D1.81.D0.BB.D0.B0_2</p>\n", "parameters": ["num", "main_units"], "funcdef": "def"}, {"fullname": "tempgen.libs.num2t4ru.decimal2text", "modulename": "tempgen.libs.num2t4ru", "qualname": "decimal2text", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "places", "int_units", "exp_units"], "funcdef": "def"}, {"fullname": "tempgen.module", "modulename": "tempgen.module", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.module.Tempgen", "modulename": "tempgen.module", "qualname": "Tempgen", "type": "class", "doc": "<p>Class that generates files from templates with template entries replaced</p>\n\n<p>Typical workflow is as follows:</p>\n\n<ul>\n<li>call load_template, which parses template based on its extension using map from Parsers instance</li>\n<li>change fields</li>\n<li>call save_result with changed fields as replacements argument</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>fields</strong> (Dict[str, Dict[str, Any]]):\nDictionary, containing parsed entries from templates, entry id is used as key, value is a dictionary,\ncontaining full entry payload</li>\n<li><strong>templates</strong> (List[str]):\nList of absolute paths to each loaded template</li>\n<li><strong>parsers</strong> (Dict[str, callable]):\nDictionary, containing supported document extensions (e.g. '.docx') as keys and handlers for text extraction and modification as values</li>\n<li><strong>transforms</strong> (Dict[str, callable]):\nDictionary containing supported \"functions\" allowed in \"pre\" and \"post\" objects as \"fn\" property value in templates, uses function name as key and\nfunction itself as value</li>\n</ul>\n"}, {"fullname": "tempgen.module.Tempgen.__init__", "modulename": "tempgen.module", "qualname": "Tempgen.__init__", "type": "function", "doc": "<p>Initializes fields and templates, creates new instances of parsers and transforms</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.find_matches", "modulename": "tempgen.module", "qualname": "Tempgen.find_matches", "type": "function", "doc": "<p>Function called on parsable's text to find entries (valid JSON objects stringified, enclosed by double curly brackets)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>text</strong> (str):\nText to find entries in</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List</strong>: List of entries, extracted from text</li>\n</ul>\n", "parameters": ["self", "text"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.load_template", "modulename": "tempgen.module", "qualname": "Tempgen.load_template", "type": "function", "doc": "<p>Parse template if possible and append it to templates list</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>template</strong> (str):\nAbsolute path to template file</li>\n</ul>\n", "parameters": ["self", "template"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.clear_templates", "modulename": "tempgen.module", "qualname": "Tempgen.clear_templates", "type": "function", "doc": "<p>Clear templates list and reset fields</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.load_external", "modulename": "tempgen.module", "qualname": "Tempgen.load_external", "type": "function", "doc": "<p>Parse JSON from external (referenced in template entries) files</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_name</strong> (str):\nFull file name (name and extension) of external resource that has to be in the same folder as template</li>\n<li><strong>template_path</strong> (str):\nAbsolute path to the template, containing reference to resource to be parsed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[Dict, List]</strong>: Object created from JSON from parsed external resource</li>\n</ul>\n", "parameters": ["self", "file_name", "template_path"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.save_external", "modulename": "tempgen.module", "qualname": "Tempgen.save_external", "type": "function", "doc": "<p>Save external resource as JSON</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_name</strong> (str):\nFull file name (name and extension) of external resource that has to be in the same folder as template</li>\n<li><strong>template_path</strong> (str):\nAbsolute path to the template containing reference to resource</li>\n<li><strong>payload</strong> (Union[Dict, List]):\nContents to be stored as JSON in file</li>\n</ul>\n", "parameters": ["self", "file_name", "template_path", "payload"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.save_result", "modulename": "tempgen.module", "qualname": "Tempgen.save_result", "type": "function", "doc": "<p>Save generated file from template with entries replaced</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n<li><strong>target_name</strong> (str):\nName (without extension) of file to save results</li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary with entries ids as keys and their substitutions as values</li>\n</ul>\n", "parameters": ["self", "template_path", "target_name", "replacements"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.save_template", "modulename": "tempgen.module", "qualname": "Tempgen.save_template", "type": "function", "doc": "<p>Update template file entries with new values from replacements</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary with entries ids as keys and their substitutions as values</li>\n<li><strong>update_externals</strong> (bool):\nFlag specifying whether external resources referenced from template should be updated with new values</li>\n</ul>\n", "parameters": ["self", "template_path", "replacements", "update_externals"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.parse_entry", "modulename": "tempgen.module", "qualname": "Tempgen.parse_entry", "type": "function", "doc": "<p>Transform raw entry from template to dictionary</p>\n\n<p>Parses JSON in entry, loads external resources, applies transforms to entry value specified in \"pre\" entry property</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>string</strong> (str):\nRaw entry string, that is valid JSON object stringified and enclosed in double curly brackets (\n   {{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar \"Baz\"\"}}}\n)</li>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict[str, Any]</strong>: Entry representation</li>\n</ul>\n", "parameters": ["self", "string", "template_path"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.compute_match", "modulename": "tempgen.module", "qualname": "Tempgen.compute_match", "type": "function", "doc": "<p>Given replacements dict (id -> value), populate to_replace dict (raw entry string -> transformed replaced value) and return to_replace</p>\n\n<p>Find matches in text, apply transforms specified in \"post\" entry property to replacement value, populate to_replace and return it</p>\n\n<p>For instance, given text \" {{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar \"Baz\"\", \"post\": [{\"fn\": \"append\", \"args\": [\" baz\"]}]}}} \",\nempty to_replace dictionary and { \"foo\": \"bar\" } as replacements dictionary, function will populate to_replace and\nto_replace will be: { \"{{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar \"Baz\"\"}}}\": \"bar baz\" }</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>text</strong> (str):\nText containing raw entries</li>\n<li><strong>to_replace</strong> (Dict[str, str]):\nDictionary mapping raw entry strings from template file text to values, provided in replacements dictionary by id</li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary mapping entry id to its value</li>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict[str, str]</strong>: Dictionary mapping raw entry string to its transformed value</li>\n</ul>\n", "parameters": ["self", "text", "to_replace", "replacements", "template_path", "args", "kwargs"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.compute_updated_template", "modulename": "tempgen.module", "qualname": "Tempgen.compute_updated_template", "type": "function", "doc": "<p>Given replacements dict (id -> value), populate to_replace dict (raw entry string -> raw entry string with replaced value) and return to_replace</p>\n\n<p>Find matches in text, generate raw entry string with replaced value for each raw entry string match,\nupdate external resources, referenced in template with replaced value (if update_externals is set to True),\npopulate to_replace with them and return to_replace dictionary</p>\n\n<p>For instance, given text \" {{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar \"Baz\"\", \"post\": [{\"fn\": \"append\", \"args\": [\" baz\"]}]}}} \",\nempty to_replace dictionary and { \"foo\": \"bar\" } as replacements dictionary, function will populate to_replace and\nto_replace will be: { \"{{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar \"Baz\"\", \"post\": [{\"fn\": \"append\", \"args\": [\" baz\"]}]}}}\": \n\"{{{\"id\": \"foo\", \"title\": \"Foo\", \"value\": \"bar\", \"post\": [{\"fn\": \"append\", \"args\": [\" baz\"]}]}}}\"}</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>text</strong> (str):\nText containing raw entries</li>\n<li><strong>to_replace</strong> (Dict[str, str]):\nDictionary mapping raw entry strings from template file text to raw entry strings with values, provided in replacements dictionary by id</li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary mapping entry id to its value</li>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n<li><strong>update_externals</strong> (bool):\nFlag specifying whether external resources referenced from template should be updated with new values</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict[str, str]</strong>: Dictionary mapping raw entry strings to raw entry strings with replaced value</li>\n</ul>\n", "parameters": ["self", "text", "to_replace", "replacements", "template_path", "update_externals"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.reload_externals", "modulename": "tempgen.module", "qualname": "Tempgen.reload_externals", "type": "function", "doc": "<p>Reload entry external resources data from template</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>template_path</strong> (str):\nAbsolute path to template file</li>\n</ul>\n", "parameters": ["self", "template_path"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.get_templates", "modulename": "tempgen.module", "qualname": "Tempgen.get_templates", "type": "function", "doc": "<p>Get list of absolute paths to loaded templates</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[str]</strong>: List of absolute paths to each loaded template</li>\n</ul>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.get_fields", "modulename": "tempgen.module", "qualname": "Tempgen.get_fields", "type": "function", "doc": "<p>Get dictionary, mapping entry id to entry representation from loaded templates</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict[str, Dict[str, Any]]</strong>: Dictionary, containing parsed entries from templates, entry id is used as key, value is a dictionary,\ncontaining full entry payload</li>\n</ul>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.module.Tempgen.set_fields", "modulename": "tempgen.module", "qualname": "Tempgen.set_fields", "type": "function", "doc": "<p>Set new/updated entries representations</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fields</strong> (Dict[str, Dict[str, Any]]):\nDictionary, containing parsed entries from templates, entry id is used as key, value is a dictionary,\ncontaining full entry payload</li>\n</ul>\n", "parameters": ["self", "fields"], "funcdef": "def"}, {"fullname": "tempgen.parsers", "modulename": "tempgen.parsers", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.Parsers", "modulename": "tempgen.parsers", "qualname": "Parsers", "type": "class", "doc": "<p>Class contains dictionary of extensions as keys and parser instances as values, providing tools for text extraction and replacement</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>ext_parser_map</strong> (Dict[str, AbstractParser]):\nDictionary containing supported file extensions, uses extension name as key\nand instance of class implementing AbstractParser interface as value</li>\n</ul>\n"}, {"fullname": "tempgen.parsers.Parsers.__init__", "modulename": "tempgen.parsers", "qualname": "Parsers.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx", "modulename": "tempgen.parsers.docx", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.docx.Parser", "modulename": "tempgen.parsers.docx", "qualname": "Parser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.docx.Parser.__init__", "modulename": "tempgen.parsers.docx", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx.Parser.paragraph_replace_text", "modulename": "tempgen.parsers.docx", "qualname": "Parser.paragraph_replace_text", "type": "function", "doc": "<p>https://github.com/python-openxml/python-docx/issues/30#issuecomment-881106471</p>\n", "parameters": ["self", "paragraph", "str", "replace_str"], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx.Parser.replace_in_paragraph", "modulename": "tempgen.parsers.docx", "qualname": "Parser.replace_in_paragraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "p", "d"], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx.Parser.collect_paragraphs", "modulename": "tempgen.parsers.docx", "qualname": "Parser.collect_paragraphs", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "doc"], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx.Parser.parse", "modulename": "tempgen.parsers.docx", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.docx.Parser.replace", "modulename": "tempgen.parsers.docx", "qualname": "Parser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.parsers.ods", "modulename": "tempgen.parsers.ods", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.ods.Parser", "modulename": "tempgen.parsers.ods", "qualname": "Parser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.ods.Parser.__init__", "modulename": "tempgen.parsers.ods", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.parsers.ods.Parser.parse", "modulename": "tempgen.parsers.ods", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.ods.Parser.replace", "modulename": "tempgen.parsers.ods", "qualname": "Parser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.parsers.odt", "modulename": "tempgen.parsers.odt", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.odt.Parser", "modulename": "tempgen.parsers.odt", "qualname": "Parser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.odt.Parser.__init__", "modulename": "tempgen.parsers.odt", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.parsers.odt.Parser.parse", "modulename": "tempgen.parsers.odt", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.odt.Parser.replace", "modulename": "tempgen.parsers.odt", "qualname": "Parser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.parsers.parser", "modulename": "tempgen.parsers.parser", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.parser.AbstractParser", "modulename": "tempgen.parsers.parser", "qualname": "AbstractParser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.parser.AbstractParser.parse", "modulename": "tempgen.parsers.parser", "qualname": "AbstractParser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.parser.AbstractParser.replace", "modulename": "tempgen.parsers.parser", "qualname": "AbstractParser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.parsers.plaintext", "modulename": "tempgen.parsers.plaintext", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.plaintext.Parser", "modulename": "tempgen.parsers.plaintext", "qualname": "Parser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.plaintext.Parser.__init__", "modulename": "tempgen.parsers.plaintext", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.parsers.plaintext.Parser.parse", "modulename": "tempgen.parsers.plaintext", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.plaintext.Parser.replace", "modulename": "tempgen.parsers.plaintext", "qualname": "Parser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.parsers.xlsx", "modulename": "tempgen.parsers.xlsx", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.parsers.xlsx.Parser", "modulename": "tempgen.parsers.xlsx", "qualname": "Parser", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n"}, {"fullname": "tempgen.parsers.xlsx.Parser.__init__", "modulename": "tempgen.parsers.xlsx", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.parsers.xlsx.Parser.parse", "modulename": "tempgen.parsers.xlsx", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parse file accessible via path property</p>\n\n<p>A general implementation of parse method should include following steps:</p>\n\n<ol>\n<li>Open file</li>\n<li>Read file data and transform it's meaningful content into string or an iterable of strings</li>\n<li>Call of find_matches function on such strings, resulting in an array of matches</li>\n<li>For each match found one should call parse_entry, resulting in an entry dictionary</li>\n<li>For each entry use entry \"id\" property as key and payload as value to populate the container provided</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>container</strong> (Dict[str, [Dict[str, Any]]]):\nDictionary to be populated with parsed entries, contains key-value pairs with entry id property as key and entry payload dictionary as value</li>\n<li><strong>parse_entry</strong> (callable):\nFunction that extracts entry (current implementation uses json parse) from matching string, returns entry payload dictionary</li>\n<li><strong>find_matches</strong> (callable):\nFunction that searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns), returns array of matching substrings</li>\n</ul>\n", "parameters": ["self", "path", "container", "parse_entry", "find_matches"], "funcdef": "def"}, {"fullname": "tempgen.parsers.xlsx.Parser.replace", "modulename": "tempgen.parsers.xlsx", "qualname": "Parser.replace", "type": "function", "doc": "<p>Replace file contents</p>\n\n<p>A general implementation of replace method should include following steps:</p>\n\n<ol>\n<li>Open file accessible via source_path in read mode</li>\n<li>Read file data and transform it so its text content becomes available for editing</li>\n<li>For each string in obtained text call compute_match, it results in an dictionary with {{VALID_JSON_OBJECT}} patterns as keys and computed substitutions as values</li>\n<li>For each match, value in the dictionary, replace match with value in text</li>\n<li>Create file at target_path and write modified text</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nAbsolute path to file to be parsed</li>\n<li><strong>target_path</strong> (str):\nAbsolute path to file to be generated</li>\n<li><strong>compute_match</strong> (callable):\nFunction that\n<ol>\n<li>searches the entry string for matches (that is, {{VALID_JSON_OBJECT}} patterns)</li>\n<li>finds entry id in replacements dictionary</li>\n<li>populates to_replace dictionary parameter with \"{{VALID_JSON_OBJECT}}\" as key and replacement string as value</li>\n<li>if update_external is True, it updates external resources with replacement string</li>\n<li>returns to_replace dictionary</li>\n</ol></li>\n<li><strong>replacements</strong> (Dict[str, str]):\nDictionary containing pairs of \"{{VALID_JSON_OBJECT}}\" keys and their replacements as values</li>\n<li><strong>update_external</strong> (bool, optional):\nBoolean, indicating whether external resources should be updated</li>\n</ul>\n", "parameters": ["self", "source_path", "target_path", "compute_match", "replacements", "update_external"], "funcdef": "def"}, {"fullname": "tempgen.tests", "modulename": "tempgen.tests", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers", "modulename": "tempgen.tests.helpers", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.BaseTextExtension", "modulename": "tempgen.tests.helpers", "qualname": "BaseTextExtension", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.BaseTextExtension.__init__", "modulename": "tempgen.tests.helpers", "qualname": "BaseTextExtension.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "text"], "funcdef": "def"}, {"fullname": "tempgen.tests.helpers.PlaintextExtension", "modulename": "tempgen.tests.helpers", "qualname": "PlaintextExtension", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.PlaintextExtension.__init__", "modulename": "tempgen.tests.helpers", "qualname": "PlaintextExtension.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file_path"], "funcdef": "def"}, {"fullname": "tempgen.tests.helpers.DocxExtension", "modulename": "tempgen.tests.helpers", "qualname": "DocxExtension", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.DocxExtension.__init__", "modulename": "tempgen.tests.helpers", "qualname": "DocxExtension.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file_path"], "funcdef": "def"}, {"fullname": "tempgen.tests.helpers.XlsxExtension", "modulename": "tempgen.tests.helpers", "qualname": "XlsxExtension", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.XlsxExtension.__init__", "modulename": "tempgen.tests.helpers", "qualname": "XlsxExtension.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file_path"], "funcdef": "def"}, {"fullname": "tempgen.tests.helpers.OdfExtension", "modulename": "tempgen.tests.helpers", "qualname": "OdfExtension", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.helpers.OdfExtension.__init__", "modulename": "tempgen.tests.helpers", "qualname": "OdfExtension.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file_path"], "funcdef": "def"}, {"fullname": "tempgen.tests.test_tempgen", "modulename": "tempgen.tests.test_tempgen", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.tests.test_tempgen.tempgen_instance", "modulename": "tempgen.tests.test_tempgen", "qualname": "tempgen_instance", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.tests.test_tempgen.tempgen_instances", "modulename": "tempgen.tests.test_tempgen", "qualname": "tempgen_instances", "type": "function", "doc": "<p></p>\n", "parameters": ["request"], "funcdef": "def"}, {"fullname": "tempgen.tests.test_tempgen.test_load_template", "modulename": "tempgen.tests.test_tempgen", "qualname": "test_load_template", "type": "function", "doc": "<p></p>\n", "parameters": ["extension", "tempgen_instance", "snapshot"], "funcdef": "def"}, {"fullname": "tempgen.tests.test_tempgen.test_save_result", "modulename": "tempgen.tests.test_tempgen", "qualname": "test_save_result", "type": "function", "doc": "<p></p>\n", "parameters": ["extension", "tempgen_instance", "snapshot"], "funcdef": "def"}, {"fullname": "tempgen.tests.test_tempgen.test_independence", "modulename": "tempgen.tests.test_tempgen", "qualname": "test_independence", "type": "function", "doc": "<p></p>\n", "parameters": ["extension", "transform", "tempgen_instances"], "funcdef": "def"}, {"fullname": "tempgen.transforms", "modulename": "tempgen.transforms", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.transforms.ru_date_month_as_string_year", "modulename": "tempgen.transforms", "qualname": "ru_date_month_as_string_year", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "tempgen.transforms.ru_monetary_ending_append", "modulename": "tempgen.transforms", "qualname": "ru_monetary_ending_append", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "args"], "funcdef": "def"}, {"fullname": "tempgen.transforms.Transforms", "modulename": "tempgen.transforms", "qualname": "Transforms", "type": "class", "doc": "<p>Class contains dictionary of function names and functions to be used in \"pre\" and \"post\" objects as \"fn\" property value in templates</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>name_transform_map</strong> (Dict[str, callable]):\nDictionary containing supported \"functions\" allowed in \"pre\" and \"post\" objects as \"fn\" property value in templates, uses function name as key and\nfunction itself as value, these functions are applied on entry value.\nValue argument is passed automatically, additional arguments to these functions are passed as \"args\" array.\nTransform functions are executed sequentially, with value from prefious transform being passed to the next one.\nTransforms used in \"pre\" object are applied to value from template entry when template is loaded, tempgen fields will contain already transformed value\nTransforms used in \"post\" object are applied to value taken from tempgen fields only when generated document is being saved, tempgen fields will not be affected</li>\n</ul>\n"}, {"fullname": "tempgen.transforms.Transforms.__init__", "modulename": "tempgen.transforms", "qualname": "Transforms.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "tempgen.utils", "modulename": "tempgen.utils", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tempgen.utils.has", "modulename": "tempgen.utils", "qualname": "has", "type": "function", "doc": "<p>Check if list has dict with matching key-value pair</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>l</strong> (List[Dict[str, Any]]):\nList to check for matches</li>\n<li><strong>key</strong> (str):\nKey to find in list's dictionaries</li>\n<li><strong>value</strong> (Any):\nValue to be compared with value in suitable key-value pair in each dictionary in list</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if list has dictionary with key-value pair matching given key and value, False otherwise.</li>\n</ul>\n", "parameters": ["l", "key", "value"], "funcdef": "def"}, {"fullname": "tempgen.utils.split_by_key_presense", "modulename": "tempgen.utils", "qualname": "split_by_key_presense", "type": "function", "doc": "<p>Split list of dictionaries into two lists based on key presense</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>l</strong> (List[Dict[str, Any]]):\nList to split</li>\n<li><strong>key</strong> (str):\nKey to find in list's dictionaries</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[List[Any], List[Any]]</strong>: First list in tuple containing l's dictionaries that have given key, second list contain l's dictionaries that don't</li>\n</ul>\n", "parameters": ["l", "key"], "funcdef": "def"}, {"fullname": "tempgen.utils.copy_func", "modulename": "tempgen.utils", "qualname": "copy_func", "type": "function", "doc": "<p>Copy function</p>\n\n<p>Based on http://stackoverflow.com/a/6528148/190597 (Glenn Maynard)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>f</strong> (callable):\nFunction to copy</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>callable</strong>: The exact independent copy of provided function</li>\n</ul>\n", "parameters": ["f"], "funcdef": "def"}, {"fullname": "tempgen.utils.make_path", "modulename": "tempgen.utils", "qualname": "make_path", "type": "function", "doc": "<p>Create nested dictionaries in path in dictionary</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>d</strong> (Dict[str, Any]):\nProvided dictionary</li>\n<li><strong>*args:</strong>: Variable length list of path segments to create if not present</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dict</strong>: Dict with nested dicts with paths items as keys</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AttributeError</strong>: If path segment already exists on the same level of provided dictionary AND is not a dictionary</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"s2\">&quot;foo&quot;</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"s2\">&quot;baz&quot;</span><span class=\"p\">:</span> <span class=\"mi\">42</span> <span class=\"p\">}</span> <span class=\"p\">}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">make_path</span><span class=\"p\">(</span><span class=\"n\">test</span><span class=\"p\">,</span> <span class=\"s2\">&quot;foo&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;bar&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;baz&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">{}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">test</span>\n<span class=\"go\">{&#39;foo&#39;: {&#39;baz&#39;: 42, &#39;bar&#39;: {&#39;baz&#39;: {}}}}</span>\n</code></pre></div>\n", "parameters": ["d", "paths"], "funcdef": "def"}, {"fullname": "tempgen.utils.extract_zip", "modulename": "tempgen.utils", "qualname": "extract_zip", "type": "function", "doc": "<p>Extract zip archive</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nPath to archive to be extracted</li>\n<li><strong>target_path</strong> (str):\nPath to directory to extract archive content</li>\n</ul>\n", "parameters": ["source_path", "target_path"], "funcdef": "def"}, {"fullname": "tempgen.utils.make_zip", "modulename": "tempgen.utils", "qualname": "make_zip", "type": "function", "doc": "<p>Create zip archive with only related paths (source_path &gt; files or directories)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>source_path</strong> (str):\nPath to directory to be archived</li>\n<li><strong>target_path</strong> (str):\nPath (with file name) where to store resulting archive</li>\n</ul>\n", "parameters": ["source_path", "target_path"], "funcdef": "def"}, {"fullname": "tempgen.utils.fix_tk_file_path", "modulename": "tempgen.utils", "qualname": "fix_tk_file_path", "type": "function", "doc": "<p>Fix issue when tk.filedialog methods (like askdirectory) yield file paths with incorrect separators using slashes instead of backslashes on Windows</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>incorrect_path</strong> (str):\nString using forward slashes like 'C:/Users/Foo/bar/baz'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Correct platform-dependent path with os.sep as separator</li>\n</ul>\n", "parameters": ["incorrect_path"], "funcdef": "def"}]